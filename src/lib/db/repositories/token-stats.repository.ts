/**
 * Token Statistics Repository
 *
 * Handles queries for input/output token metrics.
 */

import { Collections, getCollection } from "../connection";
import type {
    DateRange,
    MessageStatsResult,
    PeriodComparison,
    TokenCountResult,
} from "../types";

/**
 * Get input and output token counts with period comparison
 *
 * Uses the `transactions` collection which tracks the actual tokens consumed by LLM API calls.
 * This is the accurate source because:
 * - tokenType: 'prompt' = Total input tokens sent to the LLM (includes full conversation context)
 * - tokenType: 'completion' = Output tokens generated by the LLM
 * - rawAmount: The token count (stored as negative for spending, so we use $abs)
 *
 * Note: The `messages.tokenCount` field only counts tokens in individual messages,
 * not the full context sent to the LLM which includes all previous conversation messages.
 * The transactions collection records what was actually billed/consumed.
 */
export async function getTokenCounts(
	params: PeriodComparison,
): Promise<TokenCountResult[]> {
	const { startDate, endDate, prevStart, prevEnd } = params;
	const collection = await getCollection(Collections.TRANSACTIONS);

	const pipeline = [
		{
			$facet: {
				// Current period - Input tokens (prompt tokens sent to LLM)
				currentInput: [
					{
						$match: {
							createdAt: { $gte: startDate, $lte: endDate },
							tokenType: "prompt",
						},
					},
					{
						$group: {
							_id: null,
							// rawAmount is negative for spending, so we use $abs
							total: { $sum: { $abs: "$rawAmount" } },
						},
					},
				],
				// Previous period - Input tokens
				prevInput: [
					{
						$match: {
							createdAt: { $gte: prevStart, $lte: prevEnd },
							tokenType: "prompt",
						},
					},
					{
						$group: {
							_id: null,
							total: { $sum: { $abs: "$rawAmount" } },
						},
					},
				],
				// Current period - Output tokens (completion tokens from LLM)
				currentOutput: [
					{
						$match: {
							createdAt: { $gte: startDate, $lte: endDate },
							tokenType: "completion",
						},
					},
					{
						$group: {
							_id: null,
							total: { $sum: { $abs: "$rawAmount" } },
						},
					},
				],
				// Previous period - Output tokens
				prevOutput: [
					{
						$match: {
							createdAt: { $gte: prevStart, $lte: prevEnd },
							tokenType: "completion",
						},
					},
					{
						$group: {
							_id: null,
							total: { $sum: { $abs: "$rawAmount" } },
						},
					},
				],
			},
		},
		{
			$project: {
				currentInputToken: {
					$ifNull: [{ $arrayElemAt: ["$currentInput.total", 0] }, 0],
				},
				currentOutputToken: {
					$ifNull: [{ $arrayElemAt: ["$currentOutput.total", 0] }, 0],
				},
				prevInputToken: {
					$ifNull: [{ $arrayElemAt: ["$prevInput.total", 0] }, 0],
				},
				prevOutputToken: {
					$ifNull: [{ $arrayElemAt: ["$prevOutput.total", 0] }, 0],
				},
			},
		},
	];

	return collection.aggregate<TokenCountResult>(pipeline).toArray();
}

/**
 * Get average statistics per message with period comparison
 */
export async function getMessageStats(
	params: PeriodComparison,
): Promise<MessageStatsResult[]> {
	const { startDate, endDate, prevStart, prevEnd } = params;
	const collection = await getCollection(Collections.MESSAGES);

	const pipeline = [
		{
			$facet: {
				current: [
					{ $match: { createdAt: { $gte: startDate, $lte: endDate } } },
					{
						$group: {
							_id: null,
							totalMessages: { $sum: 1 },
							totalTokenCount: { $sum: "$tokenCount" },
							totalSummaryTokenCount: { $sum: "$summaryTokenCount" },
						},
					},
				],
				prev: [
					{ $match: { createdAt: { $gte: prevStart, $lte: prevEnd } } },
					{
						$group: {
							_id: null,
							totalMessages: { $sum: 1 },
							totalTokenCount: { $sum: "$tokenCount" },
							totalSummaryTokenCount: { $sum: "$summaryTokenCount" },
						},
					},
				],
			},
		},
		{
			$project: {
				totalMessages: {
					$ifNull: [{ $arrayElemAt: ["$current.totalMessages", 0] }, 0],
				},
				totalTokenCount: {
					$ifNull: [{ $arrayElemAt: ["$current.totalTokenCount", 0] }, 0],
				},
				totalSummaryTokenCount: {
					$ifNull: [
						{ $arrayElemAt: ["$current.totalSummaryTokenCount", 0] },
						0,
					],
				},
				prevTotalMessages: {
					$ifNull: [{ $arrayElemAt: ["$prev.totalMessages", 0] }, 0],
				},
				prevTotalTokenCount: {
					$ifNull: [{ $arrayElemAt: ["$prev.totalTokenCount", 0] }, 0],
				},
				prevTotalSummaryTokenCount: {
					$ifNull: [{ $arrayElemAt: ["$prev.totalSummaryTokenCount", 0] }, 0],
				},
			},
		},
	];

	return collection.aggregate<MessageStatsResult>(pipeline).toArray();
}

/**
 * Get request heatmap data (requests grouped by day of week and hour)
 */
export async function getRequestHeatmap(
	params: DateRange & { timezone?: string },
) {
	const { startDate, endDate, timezone = "UTC" } = params;
	const collection = await getCollection(Collections.MESSAGES);

	const pipeline = [
		{ $match: { createdAt: { $gte: startDate, $lte: endDate } } },
		{
			$project: {
				// Use hour directly (0-23) instead of 3-hour blocks
				// Use passed timezone for correct local time display
				hour: { $hour: { date: "$createdAt", timezone: timezone } },
				dayOfWeek: {
					$isoDayOfWeek: { date: "$createdAt", timezone: timezone },
				},
				date: {
					$dateToString: {
						format: "%Y-%m-%d",
						date: "$createdAt",
						timezone: timezone,
					},
				},
			},
		},
		{
			$group: {
				_id: { hour: "$hour", dayOfWeek: "$dayOfWeek", date: "$date" },
				totalRequests: { $sum: 1 },
			},
		},
		{ $sort: { "_id.date": 1, "_id.hour": 1 } },
		{
			$project: {
				_id: 0,
				dayOfWeek: "$_id.dayOfWeek",
				timeSlot: "$_id.hour",
				date: "$_id.date",
				totalRequests: 1,
			},
		},
	];

	return collection.aggregate(pipeline).toArray();
}
